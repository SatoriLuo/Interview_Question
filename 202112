1、基类中的析构函数为什么要声明未虚函数？
  在C++的类中，构造函数用于初始化对象以及相关操作，构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表喊不存在。
  析构函数则用于销毁对象完成时相应的资源释放工作，析构函数可以被声明为虚函数。在继承层次中，基类的析构函数一般建议声明为虚函数。
  现在有一个基类的指针指向派生类对象，之后释放掉基类指针所指的派生类对象，这时候如果基类的析构函数没有声明为虚函数，
  那么释放对象所调用的析构函数为基类对象的析构函数，派生类的析构函数是没有调用的。假如派生类的对象析构函数中需要释放堆上的资源，
  那么这时候就会造成内存泄露。
  如果基类的析构函数为虚函数，那么释放对象的时候就能正确的先把派生类释放掉，然后再释放基类的资源，避免内存泄露。
  
2、如何判断一个链表是否为环？
  方法1：用一个map把遍历过的节点存起来，如果map中找到和现在正在遍历的节点相同的话，就证明有环。
  方法2：快慢指针，声明两个指针都指向头结点，指针A每次走一步，指针B每次走两步，如果在循环中两个指针相遇相同，即两个指针相遇，就证明有环。
  
3、如何用udp实现tcp？
  一般需要手动实现以下特性：
  增加ack机制，确保发送到对端
  增加seq机制，实现传输顺序华
  增加MTU机制，确保传输有序缓冲
  增加数据校验机制，确保传输的正确性
  增加超时重传机制
  
  结论：
  1：添加seq/ack机制，确保数据发送到对端
  2：添加发送和接受缓冲区，主要是用户超时重传
  3：添加超时重传机制
  
4、想要反向遍历一个vector，代码如下：
  for(vector<int>::size_type i = arr.size() -1;i >= 0;i--)
  {
    cout << arr[i] << endl;
  }
  
  结果就是程序崩溃。
  崩溃的原因在于vector<int>::size_type是unsigned类型的，当i = 0再减一的时候，i就会变成一个很大的整数，在arr[i]中就会越界，造成程序崩溃。
  在mingW编译器中vector<int>::size_type类型是long long unsigned int,长度为8.
  解决方法如下：
  1：for(vector<int>::size_type i = arr.size() - 1;i >= 0 && i <= arr.size() - 1;i--)
  2: for(vector<int>::size_type i = arr.size() - 1;i >= 0;i--)
     {
         cout << arr[i] << endl;
         if(i == 0) break;
     }

5、gcc和g++有什么区别
  只要是gcc支持编译的程序代码，都可以用gcc命令完成编译。gcc是GCC编译器的通用编译指令，根据程序文件的后缀名，gcc指令可以自行判断出编程语言的类别。
  g++指令，无论目标文件的后缀名是什么，一律按照编译C++代码的方式编译。
  用gcc命令编译C++代码时，gcc默认是无法找到一些C++标准头文件的，需要手动为其添加-lstdc++ -shared-libgcc选项。
  
